////////////////////////////////////////////////////////
// set of functions for sending (recieving) data over //
// PS/2 to (from) a peripheral.                       //
////////////////////////////////////////////////////////

#include <Arduino.h>
#include "ps2_host.h"

/* returns the ascii char represnting a key */
char* get_char(int _k) {
  switch (_k) {
    case KEY_A:
      return "A";
      break;
    case KEY_B:
      return "B";
      break;
    case KEY_C:
      return "C";
      break;
    case KEY_D:
      return "D";
      break;
    case KEY_E:
      return "E";
      break;
    case KEY_F:
      return "F";
      break;
    case KEY_G:
      return "G";
      break;
    case KEY_H:
      return "H";
      break;
    case KEY_I:
      return "I";
      break;
    case KEY_J:
      return "J";
      break;
    case KEY_K:
      return "K";
      break;
    case KEY_L:
      return "L";
      break;
    case KEY_M:
      return "M";
      break;
    case KEY_N:
      return "N";
      break;
    case KEY_O:
      return "O";
      break;
    case KEY_P:
      return "P";
      break;
    case KEY_Q:
      return "Q";
      break;
    case KEY_R:
      return "R";
      break;
    case KEY_S:
      return "S";
      break;
    case KEY_T:
      return "T";
      break;
    case KEY_U:
      return "U";
      break;
    case KEY_V:
      return "V";
      break;
    case KEY_W:
      return "W";
      break;
    case KEY_X:
      return "X";
      break;
    case KEY_Y:
      return "Y";
      break;
    case KEY_Z:
      return "Z";
      break;
    case KEY_SPACE:
      return " ";
    case KEY_DOT:
      return ".";
      break;
    case KEY_COMMA:
      return ",";
    default:
      return "U";
      break;
  }
}

/* read data from periphreal, follows the following
 * proceedure:
 * 1) wait for clock LOW, or timeout after RD_TIMEOUT
 *    ms (wait for start bit).
 * 2) if (1) succeeds then wait for next time clock is
 *    LOW (host reads on clock LOW).
 * 3) read data line and set corresponding bit.
 * 4) wait for next time clock is HIGH.
 * 5) repeat 2-4 untill all eight data bits and parity
 *    bit is recieved.
 * 6) wait until clokc is LOW again and check that the
 *    data line is HIGH (stop bit) */
int read(BYTE* _b) {
  pinMode(P_CLK, INPUT_PULLUP);
  pinMode(P_CLK, INPUT_PULLUP);
  
  time_t since;
  BYTE parity = 1;
  BYTE b = 0;
  
  // wait for start bit
  WAIT_LOW(P_CLK, RD_TIMEOUT)
  
  if (digitalRead(P_DTA) != LOW) return -2; // invalid start bit recieved
  
  // read data bits
  for (int state, i = 0; i < 8; i++) {
    WAIT_FOR_NEXT_LOW(CLK_TIMEOUT)
    state = digitalRead(P_DTA);
    
    if (state == HIGH)
      parity = !parity,
      b |= 0x01 << i;
  }
  
  // read parity bit
  WAIT_FOR_NEXT_LOW(CLK_TIMEOUT)
  
  // check parity
  if (digitalRead(P_DTA) != parity) return -4; // invalid parity bit recieved
  
  // read stop bit
  WAIT_FOR_NEXT_LOW(CLK_TIMEOUT)
  
  if (digitalRead(P_DTA) != HIGH) return -5; // invalid stop bit recieved
  
  *_b = b;
  
  return 0;
}

/* write data to peripheral, folows the following
 * proceedure:
 * 1) pull clock line for 100us (request to send).
 * 2) pull data low and release clock line.
 * 3) wait for device to acknowledge the request by
 *    pulling clock low (this acts as start bit).
 * 4) write data bits when clock is LOW. NOTE:
 *    bits are read by device when clock is HIGH
 *    and clock is generated by device.
 * 5) write parity bit, as before
 * 6) wait for device to pull clock and data low,
 *    then release clock and data (this acts as
 *    stop bit). */
int write(BYTE _b) {
  BYTE parity = (
    _b & 0x80 + _b & 0x40 + _b & 0x20 +
    _b & 0x10 + _b & 0x08 + _b & 0x04 +
    _b & 0x02 + _b & 0x01) % 2;
  
  time_t since;
  
  pinMode(P_CLK, OUTPUT);
  pinMode(P_DTA, OUTPUT);
  
  // pull clock low for 100us
  digitalWrite(P_CLK, LOW);
  delayMicroseconds(100);
  
  // pull data low and release clock
  digitalWrite(P_DTA, LOW);
  digitalWrite(P_CLK, HIGH);
  
  pinMode(P_CLK, INPUT_PULLUP);
  
  // wait for device to pull clock low
  WAIT_LOW(P_CLK, WR_TIMEOUT)
  
  // write data bits
  for (int i = 0; i < 8; i++) {
    if (_b & (0x01 << i)) digitalWrite(P_DTA, HIGH);
    else digitalWrite(P_DTA, LOW);
    WAIT_FOR_NEXT_LOW(CLK_TIMEOUT)
  }
  
  // write parity bit
  if (parity) digitalWrite(P_DTA, HIGH);
  else digitalWrite(P_DTA, HIGH);
  WAIT_FOR_NEXT_LOW(CLK_TIMEOUT)
  
  // release data line
  digitalWrite(P_DTA, LOW);
  
  pinMode(P_DTA, INPUT_PULLUP);
  
  // wait for device to pull clock and data low
  WAIT_LOW(P_DTA, WR_TIMEOUT)
  WAIT_LOW(P_CLK, WR_TIMEOUT)
  
  // wait for device to release clock and data (return to idle state)
  WAIT_HIGH(P_DTA, WR_TIMEOUT)
  WAIT_HIGH(P_CLK, WR_TIMEOUT)

  return 0;
}

bool probe_status(void) {
  time_t since;
  BYTE b = 0;
  
  // send reset request
  TIMEOUT(write(0xFF), 1000, return 0; /* write timeout */)
  
  // look for acknowledgement
  TIMEOUT(read(&b), 1000, return 0; /* read timeout */)
  
  if (b != 0xFA) return 0;
  
  // read response
  TIMEOUT(read(&b), 1000, return 0; /* read timeout */)
  
  if (b != 0xAA) return 0;
  return 1;
}

bool send_echo(void) {
  time_t since;
  BYTE b = 0;
  
  // send echo request
  TIMEOUT(write(0xEE), 1000, return 0; /* write timeout */)
  
  // look for response
  TIMEOUT(read(&b), 1000, return 0; /* read timeout */)
  
  if (b != 0xEE) return 0;
  return 1;
}

void init(int _p_dta, int _p_clk) {
  P_DTA = _p_dta;
  P_CLK = _p_clk;
  pinMode(P_DTA, INPUT_PULLUP);
  pinMode(P_CLK, INPUT_PULLUP);
}
